{"version":3,"sources":["Board.js","Food.js","Game.js","Main.js","Menu.js","Score.js","Settings.js","Snake.js","Status.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../app.js","sourcesContent":["//! если в файле только один класс то его имя пишут с большой буквы (хорошая практика  - один файл - один класс)\r\nclass Board {\r\n  //! this. везде (почти) указывает на объект в котом находиться. здесь Board\r\n  constructor() {\r\n    // получаем доступ к таблице table id=\"game\"\r\n    this.boardEl = document.getElementById(\"game\");\r\n  }\r\n\r\n  /**\r\n   * Метод получает другие игровые объекты, которые нужны ему для работы.\r\n   * @param {Settings} settings объект настроек.\r\n   * @param {Snake} snake объект змейки.\r\n   */\r\n  //! через метод init мы будем передовать в какойто объект сылки на др объекты.\r\n  //! 1 Мы так конролим от чего зависит наш файл. Видно в самом init\r\n  //! 2 Более низкая связаность файлов, благодаря собственым свойствам (this.settings,this.board и пр.)\r\n  // игровому полю передаем рамеры игров поля и змейку чтоб по кордин. отрисовать её\r\n  init(settings, snake) {\r\n    this.settings = settings;\r\n    this.snake = snake;\r\n  }\r\n\r\n  /**\r\n   * Метод отрисовывает игровое поле.\r\n   */\r\n  // внешний цикл отрисует строку, а внутрений ячейки в ней. потом опять строка и ячейки\r\n  renderBoard() {\r\n    //* рефакторинг. чтоб не наруш принц един. отвеств. убрали очистку.\r\n    // очищаем игр.поле\r\n    // this.boardEl.innerHTML = \"\";\r\n    // перебираем кол-во строк из настроек (21)\r\n    for (let row = 0; row < this.settings.rowsCount; row++) {\r\n      // создаем тег \"tr\"\r\n      let tr = document.createElement(\"tr\");\r\n      // обращаемся таблице и добавляем  тег \"tr\"\r\n      this.boardEl.appendChild(tr);\r\n\r\n      // смотрим сколько колонок (21)\r\n      for (let col = 0; col < this.settings.colsCount; col++) {\r\n        // создаем тег \"td\"\r\n        let td = document.createElement(\"td\");\r\n        // в tr добавляем td\r\n        tr.appendChild(td);\r\n        // по кругу создаем и добавляем теги td до 21 включительно\r\n        // идем второй раз на внешний цикл. и так до 21\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Метод отрисовывает змейку на доске.\r\n   */\r\n  // метод getSnakeBodyElems будет возращить теги \"td\" которые соответствуют координатам змейки (snake.body) и отрисовывать их присваивая класс snakeBody\r\n  renderSnake() {\r\n    // перемен. snakeBodyElems = у Board, В МЕТОД getSnakeBodyElems (получить элементы тела змейки) передаем массив с координатами из snake.body. Делаем это по сылке (this.snake) на объект Snake\r\n    const snakeBodyElems = this.getSnakeBodyElems(this.snake.body);\r\n    //* рефакторинг -. убираем проверку на ноль\r\n    // если в snakeBodyElems чтото есть\r\n    // if (snakeBodyElems) {\r\n    // перебираем snakeBodyElems\r\n    snakeBodyElems.forEach(function (tdEl) {\r\n      // и каждому тегу \"td\" добавляем класс snakeBody. класс раскрашивает змейку\r\n      tdEl.classList.add(\"snakeBody\");\r\n    });\r\n    // }\r\n  }\r\n\r\n  //* рефакторинг -.  не нужно постояно очищать поле, только змейку и еду. заместо + нов. методы\r\n  /**\r\n   * Метод очищает игровое поле.\r\n   */\r\n  // clearBoard() {\r\n  // константа tdElems = получаем все теги \"td\",\r\n  //   const tdElems = document.querySelectorAll(\"td\");\r\n  // перебираем циклом forEach все теги td\r\n  //   tdElems.forEach(function (td) {\r\n  // выставляем класс как пустую строку\r\n  //     td.className = \"\";\r\n  //   });\r\n  // }\r\n\r\n  //* рефакторинг +.\r\n  /** Метод очищает игровое поле от еды. */\r\n  clearFood() {\r\n    document.querySelector(\".food\").classList.remove(\"food\");\r\n  }\r\n\r\n  addBoard() {\r\n    const gameTbl = document.querySelector(\".gameTbl\");\r\n    gameTbl.classList.add(\"gameBoard\");\r\n  }\r\n\r\n  addBoardSup() {\r\n    const gameTbl = document.querySelector(\".gameTbl\");\r\n    gameTbl.classList.add(\"gameBoardSup\");\r\n  }\r\n\r\n  //* рефакторинг +.\r\n  /** Метод очищает игровое поле от змейки. */\r\n  clearSnake() {\r\n    const tdElems = document.querySelectorAll(\".snakeBody\");\r\n    tdElems.forEach(function (td) {\r\n      td.classList.remove(\"snakeBody\");\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Получаем набор тегов td, представляющих тело змейки.\r\n   * @param {Array} bodyCoords массив объектов с координатами\r\n   ** рефакторинг +.\r\n   * @throws {Error} если координаты не будут переданы, то будет выброшена ошибка\r\n   * @returns {HTMLTableCellElement[]}\r\n   ** рефакторинг -.\r\n  // @returns {HTMLTableCellElement[]|null} возвращается массив тегов td (HTMLTableCellElement - тег td) если были переданы координаты, иначе null.\r\n   */\r\n  getSnakeBodyElems(bodyCoords) {\r\n    // если в массиве длина равна 0, он пуст\r\n    if (bodyCoords.length === 0) {\r\n      //* рефакторинг +.\r\n      // выдаст ошибку\r\n      throw new Error(\"Не переданы координаты тела змейки.\");\r\n    }\r\n\r\n    // если прошли проверку выше, создаем массив, в который поместим теги\r\n    let bodyElems = [];\r\n    //* рефакторинг ~.\r\n    // перебираем массив\r\n    for (let coordinate of bodyCoords) {\r\n      // перемен. td = в метод getCellEl (получить элемент ячейки) передаем коорд Х и Y. получаем теги \"td\"\r\n      let td = this.getCellEl(coordinate.x, coordinate.y);\r\n      // в массив , в конец, добавляем\r\n      bodyElems.push(td);\r\n    }\r\n    // возращаем массив из тегов \"td\"\r\n    return bodyElems;\r\n  }\r\n  //* рефакторинг -. не надо лишнего null т.к. есть проверка выше\r\n  // иначе ничего\r\n  // return null;\r\n  // }\r\n\r\n  /**\r\n   * Получаем ячейку таблицы.\r\n   * @param {number} x координата по оси х.\r\n   * @param {number} y координата по оси y.\r\n   * @returns {HTMLTableCellElement} тег td\r\n   */\r\n  getCellEl(x, y) {\r\n    // возвращаем Nный  (переданый) элемент  \"tr\" и \"td\" (в виде ссылки). таким образом мы будем получать эту ячейку (тег)\r\n    // скажем первый тег \"tr\" в нем первый тег \"td\"\r\n    return this.boardEl.querySelector(`tr:nth-child(${y}) td:nth-child(${x})`);\r\n  }\r\n\r\n  /**\r\n   * Метод проверяет съела ли змейка еду.\r\n   * @returns {boolean} true если змейка находится на еде, иначе false.\r\n   */\r\n  // `голова на еде`\r\n  //* рефакторинг +. переименовка метода isHeadOnFood(`это голова на еде`) в более понятный didSnakeEatFood (`ела ли змея еду`)\r\n  didSnakeEatFood() {\r\n    // у еды (таблица(тег td) с классом .food) проверим класслист содержит (contains) ли он змейку (класс snakeBody)\r\n    // если змейка зашла на еду, тогда будут 2 класса (food, snakeBody)\r\n    return this.boardEl.querySelector(\".food\").classList.contains(\"snakeBody\");\r\n  }\r\n\r\n  //* рефакторинг -. нет изза удален класса Food.js\r\n  /**\r\n   * Метод рисует еду на игровом поле.\r\n   * @param {Object} coords будущее расположение еды на поле\r\n   * @param {number} coords.x координата x\r\n   * @param {number} coords.y координата y\r\n   */\r\n  // принимает рандомные координаты от setNewFood() {}, и дает им класс food\r\n  // renderFood(coords) {\r\n  // перемен. foodCell = получаем ячейку таблицы (getCellEl) по принятым коорд\r\n  //   const foodCell = this.getCellEl(coords.x, coords.y);\r\n  // приписываем класс\r\n  //   foodCell.classList.add(\"food\");\r\n  // }\r\n\r\n  //* рефакторинг +. случайные генер. заместо generateRandomCoordinates() из Food.js(брали случ коорд в цикле, из них брали тег td, провер нет ли в нём змейки - не оптим изза циклов).\r\n  /**\r\n   * Метод возвращает тег td у которого нет класса snakeBody или food\r\n   * @returns {HTMLTableCellElement}\r\n   */\r\n  getRandomEmptyTd() {\r\n    // в перем = получ все теги td у которых нет .snakeBody и .food. получ изначально пустые классы\r\n    const emptyTdElements = document.querySelectorAll(\r\n      \"td:not(.snakeBody):not(.food)\"\r\n    );\r\n    // в перем = у пуст. тегов берем случ. число * на ограничитель(длинна массива - 1) и обрас. дробн. часть. получим случ. индекс тега td\r\n    const randomEmptyTd =\r\n      emptyTdElements[Math.floor(Math.random() * (emptyTdElements.length - 1))];\r\n    return randomEmptyTd;\r\n  }\r\n\r\n  //* рефакторинг +. весь функ-ал еды. Удален целый класс Food.js т.к. на каждом ходе теперь уже не надо очищать игр поле и снова ставить еду на место, то и нет необходимости хранить объект с состоянием координат еды. еда очищаеться только если её ест змейка. тогда какому нить тегу td присвоим класс food\r\n  /**\r\n   * Метод устанавливает новое случайное положение еды на игровом\r\n   * поле.\r\n   */\r\n  renderNewFood() {\r\n    // получ случайный пустой тег td\r\n    const emptyTd = this.getRandomEmptyTd();\r\n    // даём .food. класс удалится если змейка его съест. если съест, снова выз renderNewFood()\r\n    emptyTd.classList.add(\"food\");\r\n  }\r\n\r\n  /**\r\n  //  // *@deprecated Метод больше не используется, т.к. теперь змейка может проходить через стены.\r\n   *\r\n   * Является ли следующий шаг, шагом в стену.\r\n   * @param {Object} nextCellCoords - координаты ячейки, куда змейка собирается сделать шаг.\r\n   * @param {number} nextCellCoords.x\r\n   * @param {number} nextCellCoords.y\r\n   * @returns {boolean}\r\n   */\r\n  // в таблице нумерация идет с 1. с правого верхнего края. по гориз Х, по вертик Y\r\n  isNextStepToWall(nextCellCoords) {\r\n    // переменная nextCell = получаем ячейку таблицы по коорд\r\n    let nextCell = this.getCellEl(nextCellCoords.x, nextCellCoords.y);\r\n    return nextCell === null;\r\n    // если коорд идентичны null\r\n    // if (nextCell === null) {\r\n    //   // возврат истина\r\n    //   return true;\r\n    // }\r\n    // // иначе ложь\r\n    // return false;\r\n  }\r\n\r\n  // isNextStepToWall() {\r\n  //   // перемен. nexttd = в метод getCellEl (получить элемент ячейки) передаем коорд Х и Y. получаем теги \"td\"\r\n  //   let nextTd = this.getCellEl(coordinate.x, coordinate.y);}\r\n  //   // перемен. snakeBodyElems = у Board, В МЕТОД getSnakeBodyElems (получить элементы тела змейки) передаем массив с координатами из snake.body. Делаем это по сылке (this.snake) на объект Snake\r\n  //   const snakeBodyElems = this.getSnakeBodyElems(this.snake.body);\r\n\r\n  //   return this.snake.body.length == this.settings.winLength;\r\n}\r\n","//* рефакторинг -. удален целый класс\r\n// т.к. на каждом ходе теперь уже не надо очищать игр поле и снова ставить еду на место, то и нет необходимости хранить объект с состоянием координат еды. еда очищаеться только если её ест змейка. тогда какому нить тегу td присвоим класс food\r\n// class Food {\r\n//   constructor() {\r\n//     // коорд где храниться еда\r\n//     this.x = null;\r\n//     this.y = null;\r\n//   }\r\n\r\n//   /**\r\n//    *! Метод init получает другие игровые объекты, которые нужны ему для работы.\r\n//    * @param {Settings} settings объект настроек\r\n//    * @param {Snake} snake объект змейки\r\n//    * @param {Board} board объект игрового поля\r\n//    */\r\n//   //! через метод init мы будем передовать в какойто объект сылки на др объекты.\r\n//   //! 1 Мы так конролим от чего зависит наш файл. Видно в самом init\r\n//   //! 2 Более низкая связаность файлов, благодаря собственым свойствам (this.settings,this.board и пр.)\r\n//   // настройки - чтоб знала размеры игрвого поля и не появилась за его пределами; змейка - чтоб еда не появилась на ней; игровое поле - чтоб отрисовала еду\r\n//   init(settings, snake, board) {\r\n//     this.settings = settings;\r\n//     this.snake = snake;\r\n//     this.board = board;\r\n//   }\r\n\r\n//   /**\r\n//    *! Метод устанавливает новое случайное положение еды на игровом поле.\r\n//    */\r\n//   setNewFood() {\r\n//     // перемен. coords = генерируем случайные коорд с едой\r\n//     const coords = this.generateRandomCoordinates();\r\n//     // игровому полю передает коорд для отрисовки\r\n//     this.board.renderFood(coords);\r\n//   }\r\n\r\n//   /**\r\n//    *! Метод устанавливает на игровом поле еду по текущим координатам.\r\n//    */\r\n//   setFood() {\r\n//     // в метод renderFood предает коорд еды\r\n//     this.board.renderFood(this);\r\n//   }\r\n\r\n//   /**\r\n//    *! Метод генерирует новый объект еды со случайным положением на игровом поле\r\n//    * @returns {Food}\r\n//    */\r\n//   generateRandomCoordinates() {\r\n//     while (true) {\r\n//       //! получаем коорд Х\r\n//       // this.x = случайное число (Math.random()(случайное число от 0 до 1, 1 не включая)) умножаем на число колонок (this.settings.colsCount)(чтоб не выходило за пределы поля), прибавляем 1 (для начала - нумерация начинаеться с 1, нет нулевого элемента, и для конца(захватить последнию колонку)) и отбрасываем дробную часть (Math.floor)\r\n//       this.x = Math.floor(Math.random() * this.settings.colsCount + 1);\r\n//       //! получаем коорд Y\r\n//       this.y = Math.floor(Math.random() * this.settings.rowsCount + 1);\r\n//       // по этим коорд получим ячейку\r\n//       let cell = this.board.getCellEl(this.x, this.y);\r\n//       // проверяем ячейку на присутствие значений\r\n//       if (cell === null) {\r\n//         // если их нет, цикл запускается заново\r\n//         continue;\r\n//       }\r\n//       // проверяем не явлеется ли она телом змейки\r\n//       if (cell.classList.contains(\"snakeBody\")) {\r\n//         continue;\r\n//       }\r\n//       // возрашает рандом. коорд. еды\r\n//       return this;\r\n//     }\r\n//   }\r\n// }\r\n","class Game {\r\n  //! this везде (почти) указывает на объект в котом находиться. здесь Game\r\n  constructor() {\r\n    // возвращаемый идентефикатор функции SetInterval\r\n    this.tickIdentifier = null;\r\n    // ссылка на div id=message\r\n    this.messageEl = document.getElementById(\"message\");\r\n  }\r\n\r\n  /**\r\n   * Метод получает другие игровые объекты, которые нужны ему для работы.\r\n   * @param {Settings} settings\r\n   * @param {Status} status\r\n   * @param {Board} board\r\n   * @param {Snake} snake\r\n   * @param {Menu} menu\r\n   * @param {Score} score\r\n   //* рефакторинг -. класс удалён\r\n   //  @param {Food} food\r\n   */\r\n  //! через метод init мы будем передовать в какойто объект сылки на др объекты.\r\n  //! 1 Мы так конролим от чего зависит наш файл. Видно в самом init\r\n  //! 2 Более низкая связаность файлов, благодаря собственым свойствам (this.settings,this.board и пр.)\r\n  init(settings, status, board, snake, menu, score) {\r\n    this.settings = settings;\r\n    this.status = status;\r\n    this.board = board;\r\n    this.snake = snake;\r\n    this.menu = menu;\r\n    this.score = score;\r\n  }\r\n\r\n  //* рефакторинг -. частичный перенос метода в Controls.js, чтоб не было растянутости метода\r\n  /**\r\n   * Метод назначает обработчики на события клика на кнопки \"Старт\", \"Пауза\", а также на стрелки на клавиатуре.\r\n   */\r\n  // run() {\r\n  //  this.score.setToWin(this.settings.winLength);\r\n  // у объекта game по ссылке на menu вызываем метод addButtonsClickListeners, которая передает туда функции\r\n  //   this.menu.addButtonsClickListeners(\r\n  // ссылка на функцию старт\r\n  // метод bind (привязывать) создает такую же функц что перед ним(сейчас start), но для того что передаем в нём(сейчас объект Game)\r\n  // в результате вернёться функция \"f bound start()\".bound -связаный. привязаный this\r\n  //(bind(this)жестко привязывает к Game и тут же передаеться в метод addButtonsClickListeners)\r\n  // this указывает на то кто вызывает функцию\r\n  //это нужно для дальнейшего использования в Game, потому что функцию start вызывает кнопка startBtnEl из объекта Menu.\r\n  //     this.start.bind(this),\r\n  // ссылка на  функц пауза\r\n  //     this.pause.bind(this)\r\n  //   );\r\n  // слушаем событие keydown (нажатие \"на кнопку вниз\") - выполн функц pressKeyHandler(направляет змейку по кнопкам), bind(this)(привязанную к Game)\r\n  //   document.addEventListener(\"keydown\", this.pressKeyHandler.bind(this));\r\n  // }\r\n\r\n  /**\r\n   * Метод запускает игру.\r\n   */\r\n  start() {\r\n    // если статус \"на паузе\"\r\n    if (this.status.isPaused()) {\r\n      // ставим статус что \"играть\"\r\n      this.status.setPlaying();\r\n      console.log(\"start\");\r\n      // перемен tickIdentifier = вызов метода setInterval (вызов функц через интервал), для фун.doTick, через 1 сек деленую на скорость змейки.\r\n      this.tickIdentifier = setInterval(\r\n        // метод setInterval будет вызывать объект windows, но для дальнейшей работы, методом bind, создаем новую функцию doTick, в самом Game\r\n        this.doTick.bind(this),\r\n        // вызываем через каждую секунду делённую на скорость. чем больше скорость змейки, тем чаше обновляеться изменения на поле\r\n        1000 / this.settings.speed\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Метод ставит игру на паузу.\r\n   */\r\n  // императивный код(говорим как делать, по шагам)\r\n  pause() {\r\n    //если статус \"играем\"\r\n    if (this.status.isPlaying()) {\r\n      // ставим статус \"пауза\"\r\n      this.status.setPaused();\r\n      console.log(\"paus\");\r\n      //* рефакторинг +. более понятное назв функции(вызов зациклиного обновления)\r\n      this.stopGame();\r\n      //* рефакторинг -. оборачиваем вызов зациклиного обновления в отдельную функц stopGame\r\n      // останавливаем игру (остановл вызов фун tickIdentifier)\r\n      // clearInterval(this.tickIdentifier);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Метод устанавливает границы поля\r\n   */\r\n  speeding() {\r\n    // for (let x = 0; x < 100; x++) {\r\n    // if (start()) {\r\n    // if (this.status.isPaused() || this.status.setPaused()) {\r\n    // if ((this.status.condition = \"paused\")) {\r\n    // ??? не раб изменен стиля после повтор нажатия\r\n    if (this.status.condition === \"paused\") {\r\n      this.board.addBoard();\r\n      console.log(\"вкл борт\");\r\n      // ??? не раб вкл метода при нажат на кнопку\r\n      this.snake.stepZero();\r\n    }\r\n    // if (pause()) {\r\n    // if (this.status.isPlaying() || this.status.setPlaying()) {\r\n    // if ((this.status.condition = \"playing\")) {\r\n    if (this.status.condition === \"playing\") {\r\n      this.board.addBoardSup();\r\n      console.log(\"вкл суп\");\r\n      this.snake.stepZero();\r\n    }\r\n    // }\r\n    // if (this.status.setSpeed()) {\r\n    // this.status.setSpeed();\r\n    // this.board.addBoard();\r\n    // this.snake.stepZero();\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * Этот метод запускается каждую секунду и осуществляет:\r\n   * 1. перемещение змейки\r\n   * 2. проверяет проиграна/выиграна ли игра\r\n   * 3. увеличивает размер змейки если она ест еду\r\n   * 4. заново отрисовывает положение змейки и еды\r\n   *  Двигает всё игру\r\n   */\r\n  // только декларативный код(говорим что делать, а не как делать )\r\n  doTick() {\r\n    // метод меняет координаты змейки(делает шаг)\r\n    this.snake.performStep();\r\n\r\n    // ??? не раб вкл метода при нажат на кнопку\r\n    // this.snake.stepZero();\r\n\r\n    //??? не раб , перебивает паузу, не раб кнопка проверка на вхождение в стенку\r\n    // if (this.board.addBoard() || this.board.addBoardSup()) {\r\n    // if (this.status.isSpeed()) {\r\n    // if (this.status.setSpeed()) {\r\n    //   // this.isGameLost();\r\n    //   console.log(3);\r\n    //   // this.snake.stepZero();\r\n    // this.snake.stepZero();\r\n    // }\r\n\r\n    // if (this.isGameLost()) {\r\n    //   return;\r\n    // }\r\n\r\n    // if (this.status.isSpeed()) {\r\n    //   this.snake.stepZero();\r\n    // }\r\n\r\n    //* рефакторинг -.на каждом шаге вывод текущего счёта. нет смысла т.к. счёт меняется когда змейка ест\r\n    // this.score.setCurrent(this.snake.body.length);\r\n    //* рефакторинг +. проверка наступания на себя, если да то, остановка игры, вывод смс проигрыша, возвр. результ\r\n    if (this.isSnakeSteppedOntoItself()) {\r\n      this.stopGame();\r\n      this.setMessage(\"Вы проиграли\");\r\n      return;\r\n    }\r\n    //* рефакторинг +. е/и змейка съела еду, то увели. тело, отрисов. текущ. счёт\r\n    if (this.board.didSnakeEatFood()) {\r\n      this.snake.increaseBody();\r\n      this.score.renderCurrentScore(this.snake.body.length);\r\n      //* рефакторинг +. проверка идет в цикле, где змейка уже съела еду\r\n      // если вернулась истина из метода isGameWon(выйгрышная длина), то остановка игры, вывод смс победы, возвр. результ\r\n      if (this.isGameWon()) {\r\n        this.stopGame();\r\n        this.setMessage(\"Вы выиграли\");\r\n        return;\r\n      }\r\n      //* рефакторинг +. проверка идет в цикле, где змейка уже съела еду\r\n      // текущ. еду очищаем, ставим новую еду\r\n      this.board.clearFood();\r\n      this.board.renderNewFood();\r\n      //* рефакторинг -.\r\n      // в board проверяем `находить голова на еде`\r\n      // if (this.board.didSnakeEatFood()) {\r\n      // увеличиваем тело змейки\r\n      // this.snake.increaseBody();\r\n      // ставим новую еду\r\n      // this.food.setNewFood();\r\n    }\r\n    //* рефакторинг +. на каждом шагу очищаем змейку, отрисовыем по новой т.к. коорд. поменялись\r\n    this.board.clearSnake();\r\n    this.board.renderSnake();\r\n    //* рефакторинг -.\r\n    // очищает игровое поле\r\n    // this.board.clearBoard();\r\n    // выставляет еду\r\n    // this.food.setFood();\r\n  }\r\n\r\n  //* рефакторинг +. ввели принцип единой ответствености\r\n  /**\r\n   * Метод проверяет выиграна ли игра.\r\n  // юлоше не нужно - останавливает игру, выводит сообщение о выигрыше.\r\n   * @returns {boolean} если длина змейки достигла длины нужной для выигрыша, тогда true, иначе false.\r\n   */\r\n  isGameWon() {\r\n    //* рефакторинг +. теперь только проверка победы\r\n    return this.snake.body.length == this.settings.winLength;\r\n    //* рефакторинг -.\r\n    // если у змейки длина координат равна победной длине из настроек\r\n    // if (this.snake.body.length == this.settings.winLength) {\r\n    // останавливает обновления всего, игру\r\n    // clearInterval(this.tickIdentifier);\r\n    // в div с id=message выводит смс\r\n    // this.setMessage(\"Вы выиграли\");\r\n    //   return true;\r\n    // }\r\n    // return false;\r\n  }\r\n\r\n  /**\r\n   * Метод проверяет съела ли змейка сама себя.\r\n   * @returns {boolean}\r\n   */\r\n  isSnakeSteppedOntoItself() {\r\n    // есть альтернативное решение гдет в дз уроках\r\n    let cellArr = this.snake.body.map(function (cellCoords) {\r\n      return cellCoords.x.toString() + cellCoords.y.toString();\r\n    });\r\n    let head = cellArr.shift();\r\n    //* рефакторинг +. проверяем наступили ли на себя\r\n    return cellArr.includes(head);\r\n    //* рефакторинг -.\r\n    // е/и наступили на себя\r\n    // if (cellArr.includes(head)) {\r\n    // тогда останов игру\r\n    //   clearInterval(this.tickIdentifier);\r\n    // вывод смс\r\n    //   this.setMessage(\"Вы проиграли\");\r\n    //   return true;\r\n    // }\r\n    // return false;\r\n\r\n    /* \r\n        [\r\n            {x: 1, y: 1}\r\n            {x: 1, y: 2}\r\n            {x: 1, y: 3}\r\n        ]\r\n        [\r\n            \"11\", \"12\", \"13\"\r\n        ]\r\n        */\r\n  }\r\n\r\n  stopGame() {\r\n    clearInterval(this.tickIdentifier);\r\n  }\r\n\r\n  //* рефакторинг -. Устаревший метод\r\n  /**\r\n  // // * @deprecated Метод больше не используется, т.к. теперь змейка может проходить через стены.\r\n   *\r\n   * Метод проверяет врезались ли в стену, останавливает игру, выводит смс о проигрыше.\r\n   * @returns {boolean} если мы шагнули в стену, тогда true, иначе false.\r\n   */\r\n  isGameLost() {\r\n    // если мы шагнули в стену\r\n    // в board в метод isNextStepToWall передаём коорд тела змейки равные [0]\r\n    if (this.board.isNextStepToWall(this.snake.body[0])) {\r\n      // if (this.board.isNextStepToWall === this.snake.body[0]) {\r\n      // return this.snake.body.length == this.settings.winLength;\r\n      // clearInterval(this.tickIdentifier);\r\n      this.stopGame();\r\n      // вывод сообщения через метод setMessage\r\n      this.setMessage(\"Вы врезались в стену\");\r\n      return true;\r\n    }\r\n    // if (this.isGameWon()) {\r\n    //   this.stopGame();\r\n    //   this.setMessage(\"Вы выиграли\");\r\n    //   return;\r\n    // }\r\n    // иначе ложь\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * В зависимости от нажатой кнопки (вверх, вниз, влево, вправо) будет вызываться соответствующий метод.\r\n   * @param {KeyboardEvent} event\r\n   */\r\n  pressKeyHandler(event) {\r\n    // переключаеться (switch) при событии (event) на клавише (key)\r\n    switch (event.key) {\r\n      // если \"стрелка вверх\"\r\n      case \"ArrowUp\":\r\n        // у змейкм вызываем метод changeDirection и передаём направление\r\n        this.snake.changeDirection(\"up\");\r\n        break;\r\n      case \"ArrowDown\":\r\n        this.snake.changeDirection(\"down\");\r\n        break;\r\n      case \"ArrowLeft\":\r\n        this.snake.changeDirection(\"left\");\r\n        break;\r\n      case \"ArrowRight\":\r\n        this.snake.changeDirection(\"right\");\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Метод выводит сообщение на странице.\r\n   * @param {string} text\r\n   */\r\n  // принимает параметр\r\n  setMessage(text) {\r\n    // обращаеться к div id=message и вписывает принятый текст\r\n    this.messageEl.innerText = text;\r\n  }\r\n}\r\n","// ждем когда всё загрузится и потом выполняем\r\nwindow.addEventListener(\"load\", () => {\r\n  // создание объектов классов\r\n  // объект(класс) настроек\r\n  const settings = new Settings();\r\n  // статус\r\n  const status = new Status();\r\n  // объект змейки\r\n  const snake = new Snake();\r\n  // объект (класс) игрового поля\r\n  const board = new Board();\r\n  // объект контроль, элементы управления(бывший меню). отвечает за работу кнопок(старт, пауза), счётчика и пр.\r\n  const controls = new Controls();\r\n  // еда. класс удален\r\n  // const food = new Food();\r\n  // объект игры\r\n  const game = new Game();\r\n  // счёт игры\r\n  const score = new Score();\r\n\r\n  // Передача настроек\r\n  //* рефакторинг +. свои настр. в перемен\r\n  const initialSettings = { speed: 5, winLength: 7 };\r\n\r\n  //  в классе settings метод init (установка начальных значений). в виде объекта передаем настройки для нашей игры(скорость, длина для выйгрыша)\r\n  settings.init(initialSettings);\r\n  //* рефакторинг -. терь передае через переменную\r\n  // settings.init({ speed: 5, winLength: 5 });\r\n  // змейке перед настройки\r\n  snake.init(settings);\r\n  // передаем в board через init, настройки и змейку\r\n  board.init(settings, snake);\r\n  //* рефакторинг -. класс удалён. в food передаем настройки,змейку и игр поле\r\n  // food.init(settings, snake, board);\r\n  // в game передаем ссылки на объекты\r\n  game.init(settings, status, board, snake, controls, score);\r\n  //\r\n  score.init(settings);\r\n  //* рефакторинг +. в контрол передаем класс game\r\n  controls.init(game);\r\n\r\n  //* рефакторинг +. запуск\r\n  // отрисовываем игровое поле\r\n  board.renderBoard();\r\n  //* рефакторинг +. отрисов. змейку\r\n  board.renderSnake(snake);\r\n  // board.renderSnake();\r\n  //* рефакторинг +.\r\n  score.renderPointsForWin(initialSettings.winLength);\r\n  //* рефакторинг +. создаем новую еду\r\n  board.renderNewFood();\r\n  // food.setNewFood();\r\n  //* рефакторинг +.\r\n  score.renderCurrentScore(snake.body.length);\r\n  //* рефакторинг +. в классе controls(эл. управл.), вызов слуш.событ.\r\n  controls.addControlsEventListeners();\r\n  //* рефакторинг -. была часть запусков, расбросаное управление\r\n  // метод обработчика сотытия клика\r\n  // game.run();\r\n\r\n  // score.renderCurrentSpeed(initialSettings.winLength);\r\n  score.renderCurrentSpeed(initialSettings.speed);\r\n});\r\n\r\n// изучить принципы SOLID\r\n\r\n// Принцип единственной ответственности (Single Responsibility Principle)\r\n// Существует лишь одна причина, приводящая к изменению класса.\r\n// Один класс должен решать только какую-то одну задачу.\r\n\r\n// Принцип открытости/закрытости (Open-closed Principle)\r\n// Программные сущности должны быть открыты для расширения, но закрыты для модификации.\r\n// Программные сущности (классы, модули, функции и прочее) должны быть расширяемыми без изменения своего содержимого.\r\n\r\n// Принцип подстановки Барбары Лисков (Liskov Substitution Principle)\r\n// Функции, использующие указатели ссылок на базовые классы, должны уметь использовать объекты производных классов, даже не зная об этом.\r\n// Попросту говоря: подкласс/производный класс должен быть взаимозаменяем с базовым/родительским классом.\r\n\r\n// Принцип разделения интерфейса (Interface Segregation Principle)\r\n// Нельзя заставлять клиента реализовать интерфейс, которым он не пользуется.\r\n// Это означает, что нужно разбивать интерфейсы на более мелкие, лучше удовлетворяющие конкретным потребностям клиентов.\r\n\r\n// Принцип инверсии зависимостей (Dependency Inversion Principle)\r\n// Высокоуровневые модули не должны зависеть от низкоуровневых. Оба вида модулей должны зависеть от абстракций.\r\n// Абстракции не должны зависеть от подробностей. Подробности должны зависеть от абстракций.\r\n// Проще говоря: зависьте от абстракций, а не от чего-то конкретного.\r\n\r\n// Инкапсуляция - размещение в одном компоненте/классе/файле/структуре данных/методов/функций/свойств, которые с ними работают(в Board размещать только то относится к полу(таблица, игровое поле, отрисовка и очистка его, отрисовка змейки и еды, проверка на аварию с полем))\r\n\r\n//! если в файле только один класс то его имя пишут с большой буквы (хорошая практика  - один файл - один класс)\r\n\r\n//! this. везде (почти) указывает на объект в котом находиться. здесь Board\r\n\r\n//! через метод init мы будем передовать в какойто объект сылки на др объекты.\r\n//! 1 Мы так конролим от чего зависит наш файл. Видно в самом init\r\n//! 2 Более низкая связаность файлов, благодаря собственым свойствам (например в Board.js - this.settings,this.board)\r\n","//* рефакторинг +. переимен Menu. терь здесь элементы управления\r\nclass Controls {\r\n  constructor() {\r\n    // получаем button id=startBtn\r\n    this.startBtnEl = document.getElementById(\"startBtn\");\r\n    // получаем button id=pauseBtn\r\n    this.pauseBtnEl = document.getElementById(\"pauseBtn\");\r\n\r\n    this.speedBtnEl = document.getElementById(\"speedBtn\");\r\n  }\r\n\r\n  //* рефакторинг +. перед. объ Game со start и pause\r\n  /**\r\n   * @param {Game} game\r\n   */\r\n  init(game) {\r\n    this.game = game;\r\n  }\r\n\r\n  /**\r\n   //* рефакторинг +. назнач. слуш.соб. для эл. управл.\r\n   * Метод устанавливает обработчики событий на клики по кнопкам \"старт\" и \"пауза\", а также на стрелки перемещения змейки.\r\n   //* рефакторинг -.\r\n   // // Метод назначает переданные функции в качестве обработчиков событий клика на кнопки \"Старт\" и \"Пауза\".\r\n   // // @param {Function} startBtnClickHandler\r\n   // // @param {Function} pauseBtnClickHandler\r\n   */\r\n  //* рефакторинг +. не приним. функц. из вне, т.к. передали сюда объ. game с этими функциями(старт,пауза)\r\n  addControlsEventListeners() {\r\n    //* рефакторинг -. растянутая логикс на 2 класса\r\n    // // принимает в два аргумента (start- и pause- BtnClickHandler(обработчики клика кнопок старт и пауза)), параметра из game (в виде функций) и запускает их при клике\r\n    // addButtonsClickListeners(startBtnClickHandler, pauseBtnClickHandler)\r\n\r\n    //* рефакторинг +. у кнп. старт слуш. клик, у получен. функц старт из объ game с жёстко привязаным this к game\r\n    this.startBtnEl.addEventListener(\"click\", this.game.start.bind(this.game));\r\n    //* рефакторинг -.\r\n    // // кнопке старт говорим что при клике вызывай эту функцию startBtnClickHandler\r\n    // this.startBtnEl.addEventListener(\"click\", startBtnClickHandler);\r\n    //* рефакторинг +. рефакторинг +. у кнп. пауза слуш. клик, у получен. функц старт из объ game с жёстко привязаным this к game\r\n    this.pauseBtnEl.addEventListener(\"click\", this.game.pause.bind(this.game));\r\n    //* рефакторинг -.\r\n    // // кнопке пауза назнач. обработку клика для запуска функции pauseBtnClickHandler\r\n    // this.pauseBtnEl.addEventListener(\"click\", pauseBtnClickHandler);\r\n\r\n    // ??? не раб кнопка\r\n    this.speedBtnEl.addEventListener(\r\n      \"click\",\r\n      this.game.speeding.bind(this.game)\r\n    );\r\n\r\n    //* рефакторинг +.\r\n    // слушаем событие keydown (нажатие \"на кнопку вниз\") - выполн функц pressKeyHandler(направляет змейку по кнопкам), bind(this)(привязанную к Game)\r\n    // document.addEventListener(\"keydown\", this.pressKeyHandler.bind(this));\r\n    document.addEventListener(\r\n      \"keydown\",\r\n      this.game.pressKeyHandler.bind(this.game)\r\n    );\r\n  }\r\n}\r\n","class Score {\r\n  constructor() {\r\n    this.currentEl = document.querySelector(\".current\");\r\n    this.toWinEl = document.querySelector(\".toWin\");\r\n    this.speedEl = document.querySelector(\".curSpeed\");\r\n  }\r\n\r\n  /**\r\n   * @param {Settings} settings настройки игры\r\n   */\r\n  init(settings) {\r\n    this.settings = settings;\r\n  }\r\n\r\n  /**\r\n   * Метод устанавливает текущий счет игрока.\r\n   ** рефакторинг +.передаём счёт\r\n   * @param {string} score\r\n   ** рефакторинг -.\r\n   * @param {string} text\r\n   */\r\n  //* рефакторинг +. более информативное имя - `отрисовать текущий счёт`\r\n  renderCurrentScore(score) {\r\n    //* рефакторинг -.\r\n    // setCurrent(text) {\r\n    //* рефакторинг +. передаём счёт в div с кл. .current\r\n    this.currentEl.textContent = score;\r\n    //* рефакторинг -.\r\n    // this.currentEl.textContent = text;\r\n  }\r\n\r\n  /**\r\n   * Метод устанавливает количество очков, необходимых\r\n   * для выигрыша.\r\n   ** рефакторинг +. передаём очки\r\n   * @param {string} points\r\n   ** рефакторинг -.\r\n   * @param {string} points\r\n   */\r\n  //* рефакторинг +. более информативное имя - `отрисовать очки за победу`\r\n  renderPointsForWin(points) {\r\n    //* рефакторинг -.\r\n    // setToWin(text) {\r\n    //* рефакторинг +. передаём очки div с кл. .toWin\r\n    this.toWinEl.textContent = points;\r\n    //* рефакторинг -.\r\n    // this.toWinEl.textContent = text;\r\n  }\r\n\r\n  renderCurrentSpeed(speed) {\r\n    this.speedEl.textContent = speed;\r\n  }\r\n}\r\n","//! если в файле только один класс то его имя пишут с большой буквы (хорошая практика  - один файл - один класс)\r\nclass Settings {\r\n  //! this. везде (почти) указывает на объект в котором находиться. здесь Settings\r\n  /**\r\n   * @param {Object} params - Парметры игры.\r\n   * @param {number} params.rowsCount - количество строк игрового поля.\r\n   * @param {number} params.colsCount - количество колонок игрового поля.\r\n   * @param {number} params.speed - скорость перемещения змейки.\r\n   * @param {number} params.winLength - какую длину надо наесть, чтобы выиграть.\r\n   * @throws {Error} если переданы не верные настройки выбрасывается\r\n   * соответствующая ошибка.\r\n   */\r\n  // один метод на весь класс. объект settings.init({}) будет передоваться в param\r\n  // в метод init(инициализация) принимаем параметры из main\r\n  //! через метод init мы будем передовать в какойто объект сылки на др объекты.\r\n  //! 1 Мы так конролим от чего зависит наш файл. Видно в самом init\r\n  //! 2 Более низкая связаность файлов, благодаря собственым свойствам (здесь param)\r\n  //* рефакторинг +. синтаксис деструкторизации - позвол вызывать метод без передачи парам(иначе undefined)\r\n  // {... .....} = переданые сво-ва объ., формируются в параметры функции. эти значения по умолч. перзапишут то что есть в объ которому передаём\r\n  // (= {} если ничего не передано будет пустой объект)\r\n  init({ rowsCount = 21, colsCount = 21, speed = 1, winLength = 50 } = {}) {\r\n    //* рефакторинг -.\r\n    // init(params) {\r\n    // объект настроек игры по умолчанию\r\n    // rows и cols - строки и колонки табл\r\n    // speed - скорость\r\n    // winLength - длина для победы\r\n    // let defaultParams = {\r\n    //   rowsCount: 21,\r\n    //   colsCount: 21,\r\n    //   speed: 2,\r\n    //   winLength: 50,\r\n    // };\r\n    // в настройки по умолчанию заменяем передаными настройками.\r\n    //  метод Object.assign (копирует с заменой(с право на лево)) из params в defaultParams\r\n    // speed по умолч: было 2 стало 5, winLength по умолч: было 50 стало 5\r\n    // Object.assign(defaultParams, params);\r\n\r\n    // Проверки строк на соответствие тем что нужно\r\n    // проверка на строки\r\n    //* рефакторинг +. т.к.переданые параметры стали параметрами функции, то к ним нет необходимости обращаться через объект (defaultParams.rowsCount). более локанично\r\n    if (rowsCount < 10 || rowsCount > 30) {\r\n      throw new Error(\r\n        \"Неверные настройки, значение rowsCount должно быть в диапазоне [10, 30].\"\r\n      );\r\n    }\r\n    //* рефакторинг -.\r\n    // если кол-во строк  меньше 10 или больше 30 выбрасываем ощибку\r\n    // if (defaultParams.rowsCount < 10 || defaultParams.rowsCount > 30) {\r\n    // если прошли проверку, то количество строк, сохраняем в свойство (rowsCount) объекта (settings) настроек\r\n    // this.rowsCount = defaultParams.rowsCount;\r\n\r\n    // проверка на колонки\r\n    //* рефакторинг +.\r\n    if (colsCount < 10 || colsCount > 30) {\r\n      throw new Error(\r\n        \"Неверные настройки, значение rowsCount должно быть в диапазоне [10, 30].\"\r\n      );\r\n    }\r\n    //* рефакторинг -.\r\n    // if (defaultParams.colsCount < 10 || defaultParams.colsCount > 30) {\r\n    // this.colsCount = defaultParams.colsCount;\r\n\r\n    // проверка на скорость\r\n    //* рефакторинг +.\r\n    if (speed < 1 || speed > 10) {\r\n      throw new Error(\r\n        \"Неверные настройки, значение speed должно быть в диапазоне [1, 10].\"\r\n      );\r\n    }\r\n    //* рефакторинг -.\r\n    // if (defaultParams.speed < 1 || defaultParams.speed > 10) {\r\n    // this.speed = defaultParams.speed;\r\n\r\n    // проверка на выйгрышную длину\r\n    //* рефакторинг +.\r\n    if (winLength < 2 || winLength > 50) {\r\n      throw new Error(\r\n        \"Неверные настройки, значение winLength должно быть в диапазоне [5, 50].\"\r\n      );\r\n    }\r\n    //* рефакторинг -.\r\n    // if (defaultParams.winLength < 5 || defaultParams.winLength > 50) {\r\n    // this.winLength = defaultParams.winLength;\r\n\r\n    // основная логика, присваивание\r\n    this.rowsCount = rowsCount;\r\n    this.colsCount = colsCount;\r\n    this.speed = speed;\r\n    this.winLength = winLength;\r\n  }\r\n}\r\n","class Snake {\r\n  //! this. везде (почти) указывает на объект в котом находиться. здесь Snake\r\n  constructor() {\r\n    // массив с возможными направлениями змейки\r\n    this.possibleDirections = [\"down\", \"up\", \"left\", \"right\"];\r\n\r\n    // массив с координ. змейки (верхн. левый угол х0, у0)\r\n    this.body = [\r\n      {\r\n        x: 1,\r\n        y: 1,\r\n      },\r\n    ];\r\n\r\n    // направл. по умолчанию - вниз\r\n    this.direction = \"down\";\r\n  }\r\n\r\n  /**\r\n   * @param {Settings} settings настройки игры\r\n   */\r\n  init(settings) {\r\n    this.settings = settings;\r\n  }\r\n\r\n  /**\r\n   * Меняем направление движения.\r\n   ** рефакторинг ~. direction на newDirection\r\n   * @param {string} newDirection направление может быть down, up, left, right.\r\n   * @throws {Error} при передаче не корректного направления выбрасывается ошибка.\r\n   */\r\n  // принимает направления от pressKeyHandler из Game\r\n  changeDirection(newDirection) {\r\n    // если переданое направление нет среди possibleDirections, не includes (не включает в себя)\r\n    if (!this.possibleDirections.includes(newDirection)) {\r\n      // выбрасываем (throw) новую ошибку\r\n      throw new Error(\r\n        \"Передано не верное направление. Вы передали: \" + newDirection\r\n      );\r\n    }\r\n    // в метод isPassedOppositeDirection передаем (переданое направление). если переданое направ. являеться противоположным, возрашаеться истина\r\n    if (this.isPassedOppositeDirection(newDirection)) {\r\n      // return (вернуть) не позволит выполнится коду ниже\r\n      return;\r\n    }\r\n    // в свойство direction (направление) записываем новое направление(то что передали)\r\n    this.direction = newDirection;\r\n  }\r\n\r\n  /**\r\n   * Метод проверяет, является ли переданное направление, противоположным тому куда сейчас движется змейка.\r\n   * @param {string} newDirection новое направление, может быть up, down, right, left.\r\n   * @returns {boolean} true если новое направление противоположно текущему, иначе false.\r\n   */\r\n  // `передано в противоположном направлении` (с переданым параметром)\r\n  isPassedOppositeDirection(newDirection) {\r\n    // если направление = \"вниз\" и перед.направ. = \"верх\"\r\n    if (this.direction == \"down\" && newDirection == \"up\") {\r\n      // возврашаем истину.\r\n      return true;\r\n    }\r\n    if (this.direction == \"up\" && newDirection == \"down\") {\r\n      return true;\r\n    }\r\n    if (this.direction == \"left\" && newDirection == \"right\") {\r\n      return true;\r\n    }\r\n    if (this.direction == \"right\" && newDirection == \"left\") {\r\n      return true;\r\n    }\r\n    // если нет противоположных направлений, возвращяем ложь\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Метод осуществляет шаг змейки. Добавляет ячейку перед существующим положением головы и удаляет одну ячейку в хвосте.\r\n   */\r\n  // `выполнить шаг`\r\n  performStep() {\r\n    // берем текущие коорд головы (в массиве первый элемент[0])\r\n    let currentHeadCoords = this.body[0];\r\n    //* рефакторинг +. синтаксис деструкторизации. коротко.\r\n    let newHeadCoords = { ...currentHeadCoords };\r\n    //* рефакторинг -. тоже самое только длинно\r\n    // копируем их в переменную из объ. currentHeadCoords\r\n    // let newHeadCoords = {\r\n    //   x: currentHeadCoords.x,\r\n    //   y: currentHeadCoords.y,\r\n    // };\r\n    // смотрим какое направление\r\n    switch (this.direction) {\r\n      // если \"вниз\" то по Y + 1\r\n      case \"down\":\r\n        newHeadCoords.y++;\r\n        break;\r\n      // если \"вверх\" то - 1 по коорд Y\r\n      case \"up\":\r\n        newHeadCoords.y--;\r\n        break;\r\n      // если в \"лево\" по X коорд - 1\r\n      case \"left\":\r\n        newHeadCoords.x--;\r\n        break;\r\n      // если в \"право\" по X коорд + 1\r\n      case \"right\":\r\n        newHeadCoords.x++;\r\n        break;\r\n    }\r\n\r\n    // ??? не раб вкл метода при нажат на кнопку\r\n    // this.stepZero(){\r\n    // this.snake.stepZero(){\r\n    if (newHeadCoords.x > this.settings.colsCount) {\r\n      newHeadCoords.x = 1;\r\n    }\r\n    //если голова уходит за нижний край\r\n    if (newHeadCoords.y > this.settings.rowsCount) {\r\n      newHeadCoords.y = 1;\r\n    }\r\n    //если голова уходит за левый край\r\n    if (newHeadCoords.x == 0) {\r\n      newHeadCoords.x = this.settings.colsCount;\r\n    }\r\n    //если голова уходит за верхний край\r\n    if (newHeadCoords.y == 0) {\r\n      newHeadCoords.y = this.settings.rowsCount;\r\n    }\r\n    // }\r\n    this.stepZero();\r\n\r\n    // в dody добавляем в начале (новую ячейку)\r\n    this.body.unshift(newHeadCoords);\r\n    // удаляем в конце(последнию ячейку)\r\n    this.body.pop();\r\n  }\r\n\r\n  // ??? не раб вкл метода при нажат на кнопку\r\n  /**\r\n   *! Настройки ухода за стенку\r\n   *\r\n   * @memberof Snake\r\n   */\r\n  stepZero() {\r\n    // берем текущие коорд головы (в массиве первый элемент[0])\r\n    let currentHeadCoords = this.body[0];\r\n    //* рефакторинг +. синтаксис деструкторизации. коротко.\r\n    // копируем коорд. в переменную из объ. currentHeadCoords\r\n    let newHeadCoords = { ...currentHeadCoords };\r\n    // если голова уходит за правый край(коорд. Х > наст. Х, то коорд. стан. 1, т.е. появл. с др. стороны)\r\n    if (newHeadCoords.x > this.settings.colsCount) {\r\n      newHeadCoords.x = 1;\r\n    }\r\n    //если голова уходит за нижний край\r\n    if (newHeadCoords.y > this.settings.rowsCount) {\r\n      newHeadCoords.y = 1;\r\n    }\r\n    //если голова уходит за левый край\r\n    if (newHeadCoords.x == 0) {\r\n      newHeadCoords.x = this.settings.colsCount;\r\n    }\r\n    //если голова уходит за верхний край\r\n    if (newHeadCoords.y == 0) {\r\n      newHeadCoords.y = this.settings.rowsCount;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Метод дублирует в массиве объектов представляющих тело змейки последнюю ячейку, т.е. в массиве в конце оказываются два одинаковых объекта.\r\n   * Когда метод performStep в самом конце удаляет последний элемент массива, он удаляет сдублированный объект, таким образом тело змейки растет.\r\n   */\r\n  //`увеличить тело`\r\n  // императивный код(говорим как делать, по шагам)\r\n  increaseBody() {\r\n    // переменная `последняя ячейка тела` = обрашаемся к массиву body[берем его последний элемент\r\n    // (длина массива - 1(нумерация элементов с 0, потому из длины массива, скажем 3, - 1, будет 2, и это 3 элемент по счету, т.е. 0,1,2 ))]\r\n    let bodyLastCell = this.body[this.body.length - 1];\r\n    //* рефакторинг +.синтаксис деструкторизации. коротко\r\n    let newBodyLastCell = { ...bodyLastCell };\r\n    //* рефакторинг -. тоже самое только длинно\r\n    // в переменную newBodyLastCell записываем коорд последней ячейки из объ. bodyLastCell\r\n    // let newBodyLastCell = {\r\n    //   x: bodyLastCell.x,\r\n    //   y: bodyLastCell.y,\r\n    // };\r\n    // к теле змейки добавляем в конце такую же ячейку\r\n    this.body.push(newBodyLastCell);\r\n  }\r\n}\r\n","/** Здесь будет хранится статус игры, например играем мы, завершили или остановлено. */\r\nclass Status {\r\n  constructor() {\r\n    // при открытие страницы сразу ставим на паузу\r\n    // this.setPaused();\r\n    this.condition = \"paused\";\r\n  }\r\n\r\n  // Это значит что мы играем.\r\n  // включает игру\r\n  setPlaying() {\r\n    // condition (состояние) играем\r\n    this.condition = \"playing\";\r\n  }\r\n\r\n  //Это значит что игра на паузе.\r\n  setPaused() {\r\n    this.condition = \"paused\";\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} если мы сейчас играем, тогда true, иначе false.\r\n   */\r\n  // проверяет включена ли игра\r\n  isPlaying() {\r\n    return this.condition === \"playing\";\r\n  }\r\n\r\n  /**\r\n   * @returns {boolean} если сейчас игра на паузе, тогда true, иначе false.\r\n   */\r\n  isPaused() {\r\n    return this.condition === \"paused\";\r\n  }\r\n\r\n  // вкл\r\n  // ??? не раб кнопка\r\n  setSpeed() {\r\n    this.condition = \"speedi\";\r\n  }\r\n  // провер на вкл\r\n\r\n  /**\r\n   *\r\n   *\r\n   * @returns\r\n   * @memberof Status\r\n   */\r\n  isSpeed() {\r\n    if (this.condition === \"paused\") {\r\n      return this.condition === \"speedi\";\r\n    }\r\n  }\r\n}\r\n"]}